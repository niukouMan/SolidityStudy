# solidity编程

## 基本类型

### int/uint

### address

#### 长度20字节（共160位），以16进制的形式呈现
msg.sender就是当前调用方法时的发起人
this即是当前合约地址

#### payable 涉及到转账的方法都要添加payable关键字

#### 支持运算符:<=、<、==、！=、>

#### 成员方法

##### transfer（value）：从合约发起方向某个地址转入以太币(单位是wei)，地址无效或者合约发起方余额不足时，代码将抛出异常并停止转账。

##### send( value) 用来向某个地址发送货币(货币单位是wei)。
地址无效或者合约发起方余额不足时，send不会抛出异常，而是直接返回false。

###### send 是 transfer 的低级版本。

##### send()方法执行时有一些风险
调用递归深度不能超1024。
如果gas不够，执行会失败。
所以使用这个方法要检查成功与否。
transfer相对send较安全

##### call() 会改变被调用者的状态，调用者状态不会改变。
.value()附件以太币 .gas()附加gas

##### delegatecall() 会改变调用者的状态，在调用合约内会找一个相同的变量存储该值。
不支持 .value()

#### 成员变量

##### balance 地址的余额

##### this 当前合约地址

### bytesX  定长字节数组

#### 声明：bytes1 、bytes2、bytes3、bytes4 ...... bytes32  (byte的别名就是 bytes1)

#### 索引访问,只读，不可写。

#### .length 返回字节的个数。（只读）

#### 声明固定字节大小的字节数组变量，一旦声明，内部的字节和字节数组长度不可修改，当然可以通过索引读取(只读)对应索引的字节，或者通过length读取字节数组的字节数。

### bytes 动态大小字节数组

#### new bytes(长度|"")
bytes("")
创建

#### .push("");
往字节数组中添加字节

#### .length
获取长度

### bytes、bytesX、String之间转换

#### bytesX之间的转换

##### 高->低：进行低位截断

##### 低->高：进行低位补齐 

#### bytesX转bytes

##### 不能直接转换
通过一个for循环将固定大小字节数组中的字节按照索引赋给动态大小字节数组即可。(byteX->bytes->String)

#### bytesX不能直接转String

#### bytes转string

##### bytes直接转string 

### string

#### 特殊的可变长度的字节数组

#### 不能通过length获取长度

#### solidity中string功能很弱，可以使用第三工具类（字符串长度、字符串匹配、字符串拼接....）
import "http://github.com/Arachnid/solidity-stringUtils/strings.sol"
地址：http://github.com/Arachnid/solidity-stringUtils

#### bytes/string

##### bytes用来存储任意长度的字节数据

##### 用来存储UTF-8编码的字符串数据

### 数组

#### 固定长度数组

##### 创建：
例：uint [5] T = [1,2,3,4,5];
	   uint [2][3] = [[1,2],[2,3],[3,4]]

##### 不能修改数组长度
不能通过push()添加值

#### 可变长度数组

##### 声明：
uint [] T = [1,2,3,4,5];
byte [] cc = new byte[](10)   ==    byte cc = new byte(10)
使用new方式，长度不可以省略

##### 可以通过length修改长度
可以通过push()添加值

#### memory数组

##### 创建 Memory Arrays
例： uint[] memory a = new uint[](7);
创建一个长度为length的memory类型的数组可以通过new关键字来创建。
memory数组一旦创建，它不可通过length修改其长度。
memory类型的固定长度数组不可直接赋值给stroage/memory类型的可变数组。

### mapping（映射）

#### 声明：
mapping(keyType => valueType) mapName;
一对一键值对存储

#### key键的类型: 允许除映射外的所有类型，如数组，合约，枚举，结构体。
value值的类型: 无限制。

#### 索引访问
mapName[key] 如果访问一个不存在的值，返回默认值

#### 映射的局限

##### 只能作为状态变量

##### 无法遍历访问

###### 没有长度

###### 没有key集合

###### 没有value集合

###### 通过第三方库实现遍历功能
https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol

### struct

#### 声明：
struct 名称{
类型 name1;
类型 name2;...}

#### 初始化：
structName(value1,value2,value3，...);
structName(类型：value1,类型：value2,...);

#### 注意：
不能声明一个struct同时将这个struct作为这个struct的一个成员。
函数中，将一个struct赋值给一个局部变量（默认是storage类型），实际是拷贝的引用，所以修改局部变量值时，会影响到原变量。

#### 限制
结构体目前仅支持在合约内部使用，或继承合约内使用，
如果要在参数或返回值中使用结构体函数必须声明成internal

### enum（枚举）

#### 声明：
enum 名称 {值1,值2,值3,值4};
enum可以显示的转换与整数进行转换，但不能进行隐式转换。
显示的转换会在运行时检查数值范围，如果不匹配，将会引起异常。
枚举类型应至少有一名成员。

### 类型转换

#### 隐式转换
运算符两边有不同的数据类型，在不丢失数据的情况下，编译器会尝试饮食类型转换

#### 显示转换
编译器不允许隐式的自动转换，单你知道转换可能不会出问题，可以进行强转。

##### 强转需要谨慎
不正确的转换可能会带来问题
如果转换成一个更小的类型，高位会被截断

### delete(变量重置)

#### bool -> false
uint -> 0
address -> 0x0
bytes -> 0x0
string -> ""

#### delete对映射无效
delete不影响值拷贝变量

### Constant 和 Immutable 状态变量

#### 状态变量声明为 constant 或者 immutable ，在这两种情况下，合约一旦部署之后，变量将不在修改。

#### 不是所有类型的状态变量都支持用 constant 或 immutable 来修饰，当前仅支持 字符串
 (仅常量) 和 值类型
.

#### 对于 constant 变量, 他的值在编译器确定，而对于 immutable, 它的值在部署时确定。

## 存储位置

### storage

#### storage修饰的变量是指永久存储在区块链中的变量。

### memory

#### Memory修饰变量则是临时的，当外部函数对某合约调用完成时，内存型变量即被移除。

## function

### 格式 ： function name(<params types>) {public|private|interal|external}[constant|payable|] [returns(<params types>)]{ }

### 可见性修饰符

#### 可见性标识符的定义位置，对于状态变量来说是在类型后面，对于函数是在参数列表和返回关键字中间。

#### public：  可以被其他合约调用，和其内部使用
默认是public, public修饰变量会默认生成对应get方法

#### private：只能在其内部使用，子类中也不能使用

#### internal： 只能在合约内部和子合约使用,消耗的gas少，使用函数名调用

#### external：可以被其他合约使用，本合约不可直接调用需使用this.f这样调用
EVM发起的调用，使用：地址.函数名()调用

### 匿名function

#### 1.一个合约可以有一个匿名函数
，此函数不能有参数，也不能有任何返回值，当我们企图去执行一个合约上没有的函数时，那么合约就会执行这个匿名函数。

#### 2.当合约在只收到以太币的时候，也会调用这个匿名函数，而且一般情况下会消耗很少的gas,所以当你接收到以太币后，想要执行一些操作的话，你尽可以把你想要的操作写到这个匿名函数里，因为这样做成本非常便宜。

### 视图函数 view

#### 将函数声明为 view 类型，这种情况下要保证不修改状态。

#### 下面的语句被认为是修改状态

##### 1.修改状态变量。
2.产生事件。
3.创建其它合约。
4.使用 selfdestruct。
5.通过调用发送以太币。
6.调用任何没有标记为 view 或者 pure 的函数。
7.使用低级调用。
8.使用包含特定操作码的内联汇编。

### 纯函数 Pure 

#### 函数可以声明为 pure ，在这种情况下，承诺不读取也不修改状态。

##### 除了上面解释的状态修改语句列表之外，以下被认为是读取状态：
1.读取状态变量。
2.访问 address(this).balance 或者 <address>.balance。
3.访问 block，tx， msg 中任意成员 （除 msg.sig 和 msg.data 之外）。
4.调用任何未标记为 pure 的函数。
5.使用包含某些操作码的内联汇编。

### receive 接收以太函数

#### 一个合约最多有一个 receive 函数, 声明函数为： receive() external payable { ... }

#### 不需要 function 关键字，也没有参数和返回值并且必须是　external　可见性和　payable 修饰． 在对合约没有任何附加数据调用（通常是对合约转账）是会执行 receive 函数．

##### 例如　通过 .send() or .transfer() 如果 receive 函数不存在，　但是有payable　的 fallback 回退函数
 那么在进行纯以太转账时，fallback 函数会调用．如果两个函数都没有，这个合约就没法通过常规的转账交易接收以太（会抛出异常）．

### Fallback 回退函数

#### 合约可以最多有一个回退函数。
函数声明为：
fallback () external [payable]

##### 这个函数不能有参数也不能有返回值，也没有function　关键字．必须是external可见性

#### fallback函数只有 2300 gas 可以使用

### 修改器 modifer

#### 它们可以在执行函数之前自动检查某个条件。
方法修改器可以改变方法行为，比如用于函数执行前检查某种前置条件。如果满足就执行该方法否则抛出异常。

#### 函数修改器可接收参数

#### 多个修改器
如果同一个函数有多个修改器，他们之间以空格隔开，修饰器会依次检查执行。

#### 修改器是合约的可继承属性，并可能被派生合约覆盖 , 但前提是被覆盖合约需要被标记为 virtual，当前合约中的modifer需要指定 override 关键字

### 析构函数

#### selfdestruct(address) 

#### 析构函数和构造函数对应，构造函数是初始化数据，而析构函数是销毁数据。
在合约中，当我们手动调用kill函数时，就会调用selfdestruct(owner)销毁当前合约。

#### 销毁当前合约并把合约余额发送到指定地址

### 函数重写 Overriding 

#### 父合约标记为 virtual 函数可以在继承合约里重写(overridden)以更改他们的行为。重写的函数需要使用关键字 override 修饰。

### 错误处理

Solidity是通过回退状态的方式来处理错误。
发生异常时会撤消当前调用（及其所有子调用）所改变的状态，同时给调用者返回一个错误标识。
注意捕捉异常是不可能的，因此没有try … catch…。

#### Assert
用于条件检查，如果条件不满足则抛出异常。
assert函数通常用来检查（测试）内部错误，会烧掉所有的gas

#### Require
用于条件检查，如果条件不满足则抛出异常。（用于输入条件检查）
而require函数来检查输入变量或合同状态变量是否满足条件以及验证调用外部合约返回值。

#### Revert
来触发异常：
revert函数可以用来标记错误并回退当前调用，撤回所有的状态转变

##### 1. 它允许你返回一个值；
2. 它会把所有剩下的gas退回给caller

#### 注意：
1.当子调用中发生异常时，异常会自动向上“冒泡”。 不过也有一些例外：send，和底层的函数调用call, delegatecall，callcode，当发生异常时，这些函数返回false。
2.在一个不存在的地址上调用底层的函数call，delegatecall，callcode 也会返回成功，所以我们在进行调用时，应该总是优先进行函数存在性检查。

## contract 合约

### Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。

### 构造函数

#### 构造函数是可选的。只允许有一个构造函数，这意味着不支持重载。

### 抽象合约 abstract

#### 如果未实现合约中的至少一个函数，则需要将合约标记为 abstract。 即使实现了所有功能，合约也可能被标记为abstract。

### 接口 interface

#### 接口类似于抽象合约，但是它们不能实现任何函数。

#### 限制

##### 1.无法继承其他合约,不过可以继承其他接口。
2.所有的函数都需要是 external
3.无法定义构造函数。
4.无法定义状态变量。

#### 定义在接口或其他类合约结构体里的类型，可以在其他的合约里访问。接口名.名称

### 事件 Events

#### Solidity 事件是EVM的日志功能之上的抽象。 应用程序可以通过以太坊客户端的RPC接口订阅和监听这些事件。

#### 事件在合约中可被继承。

#### 当他们被调用时，会使参数被存储到交易的日志中。交易日志是一种区块链中的特殊数据结构。 这些日志与地址相关联，被并入区块链中，只要区块可以访问就一直存在，但在合约中，我们不能直接访问日志和事件数据

#### 检索日志

##### Indexed属性

###### 可以在事件参数上增加indexed属性，最多可以对三个参数增加这样的属性。加上这个属性，可以允许你在web3.js中通过对加了这个属性的参数进行值过滤，

###### 增加了indexed的参数值会存到日志结构的Topic部分，便于快速查找。而未加indexed的参数值会存在data部分，成为原始日志。

###### 如果数组，包括字符串，字节数据做为索引参数，实际主题是对应值的Keccak-256哈希值。

##### Topic

###### 日志中存储的不同的索引事件就叫不同的主题。

### 库 lib

#### 库与合约类型，但他们的目的是重用代码。通过EVM中的DELEGATECALL特性来调用部署到某个位置的库代码，就实现了复用。
DELEGATECALL指令意味着，代码是在发起调用合约的context中被执行的，因此this将指向到发起调用的合约。
library的好处是它是单实例，只会更新一个library文件，不会像contract那样因为各种依赖产生‘涟漪’效应，对于经常变动的业务逻辑代码，使用library每次更新会节省大量gas消耗。

library是需要被合约调用才能执行的，调用library的contract（下面简称A），使用的delegatecall方法，因此library执行的上下文环境在A中，也就是library的msg.sender是A，并且可以直接修改A中的storage。直白说，A调用library，就是把library的代码import到自己的内部执行了。

也就是说Solidity对于合约外部调用，返回变长类型的字段，EVM是不支持的。(string)

#### using
关键词是Solidity的contract引用library时使用

#### 库的限制

##### 1.没有状态变量
2.不能够继承或被继承
3.不能接收以太币
4.不可以被销毁 destroyed

## 内联汇编 assembly

### 为什么 Solidity 中需要用汇编

#### 细粒度控制

##### 可以使用操作码直接与 EVM 进行交互。 这使的可以对智能合约要执行的操作进行更精细控制。

##### 汇编提供了更多控制权来执行某些仅靠 Solidity 不可能实现的逻辑。

#### 更少的 Gas 消耗

#### 增强功能

### Solidity 中两种类型的汇编

#### 内联汇编（Inline Assembly )：可以在内部 Solidity 源代码中使用。

#### 独立汇编（Standalone Assembly：可以使用，无需 Solidity。

### 基本汇编语法

#### assembly { // some assembly code here}

#### 汇编代码块之间不能通信，也就是说在 一个汇编代码块里定义的变量，在另一个汇编代码块中不可以访问。

### 变量定义与赋值

#### 使用 let 关键字定义变量。

##### let 指令执行如下任务

###### 1.创建一个新的堆栈槽位
2.为变量保留该槽位
3.当到达代码块结束时自动销毁该槽位

#### 使用 := 操作符给变量赋值

### 汇编中的字面量

#### 在 Solidity 汇编中字面量的写法与 Solidity 一致。不过，字符串字面量最多可以包含 32 个字符。

### 在 Solidity 汇编中访问变量

#### 局部变量

##### 只需要使用变量名就可以访问局部变量， 无论该变量是定义在汇编块中，还是汇编块之外（Solidity 代码中），不过变量必须是函数的局部变量。

### Solidity 汇编的判断语句

#### Solidity 内联汇编支持使用 if 语句来设置代码执行的条件，但是没有其他语言中的 else 部分。

#### if 语句强制要求代码块使用大括号，即使需要保护的代码只有一行， 也需要使用大括号。

### EVM 操作码

## type 类型信息 

### 表达式 type(X) 可用于检索参数 X 的类型信息。 目前，此功能还比较有限( X 仅能是合约和整型)，但是未来应该会扩展。

### 合约类型 C

#### type(C).name:  获得合约名

#### type(C).creationCode

##### 获得包含创建合同字节码的内存字节数组。它可以在内联汇编中构建自定义创建例程，尤其是使用 create2 操作码。 不能在合同本身或派生的合同访问此属性。 因为会引起循环引用。

#### type(C).runtimeCode

##### 获得合同的运行时字节码的内存字节数组。

#### type(I).interfaceId

##### 返回接口``I`` 的 bytes4 类型的接口 ID，接口 ID 参考： EIP-165定义的

### 整型 T 

#### type(T).min     T 的最小值。

#### type(T).max    T 的最大值。

## EVM

### 以太坊虚拟机 EVM 是智能合约的运行环境。它不仅是沙盒封装的，而且是完全隔离的，也就是说在 EVM 中运行代码是无法访问网络、文件系统和其他进程的。甚至智能合约之间的访问也是受限的。

### https://learnblockchain.cn/2019/04/09/easy-evm

### 账户

#### 外部账户 由公钥-私钥对（也就是人）控制；

####  合约账户 由和账户一起存储的代码控制.

##### 合约地址是根据钱包地址+nonce生产

### 交易

#### 交易可以看作是从一个帐户发送到另一个帐户的消息。它能包含一个二进制数据（合约负载）和以太币。
如果目标账户含有代码，此代码会被执行，并以 payload 作为入参。

### Gas

#### 每笔交易都收取一定数量的 gas ，目的是限制执行交易所需要的工作量和为交易支付手续费。EVM 执行交易时，gas 将按特定规则逐渐耗尽。

### 存储，内存和栈

### 指令集

#### EVM的指令集量应尽量少，以最大限度地避免可能导致共识问题的错误实现。所有的指令都是针对”256位的字（word）”这个基本的数据类型来进行操作。具备常用的算术、位、逻辑和比较操作。也可以做到有条件和无条件跳转。此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。

### 消息调用

#### 合约可以通过消息调用的方式来调用其它合约或者发送以太币到非合约账户。消息调用和交易非常类似，它们都有一个源、目标、数据、以太币、gas和返回数据。事实上每个交易都由一个顶层消息调用组成，这个消息调用又可创建更多的消息调用。

### 委托调用/代码调用和库

#### 委托调用(delegatecall) 。它和一般的消息调用的区别在于，目标地址的代码将在发起调用的合约的上下文中执行，并且 msg.sender 和 msg.value 不变。 这意味着一个合约可以在运行时从另外一个地址动态加载代码。存储、当前地址和余额都指向发起调用的合约，只有代码是从被调用地址获取的。 这使得 Solidity 可以实现”库“能力：可复用的代码库可以放在一个合约的存储上，如用来实现复杂的数据结构的库。

### 日志

#### 一种特殊的可索引的数据结构，其存储的数据可以一路映射直到区块层级。这个特性被称为 日志(logs) ，Solidity用它来实现 事件(events) 。合约创建之后就无法访问日志数据，但是这些数据可以从区块链外高效的访问。因为部分日志数据被存储在 布隆过滤器（Bloom filter) 中，我们可以高效并且加密安全地搜索日志，所以那些没有下载整个区块链的网络节点（轻客户端）也可以找到这些日志。

#####  

### 合约创建

#### 合约甚至可以通过一个特殊的指令来创建其他合约（不是简单的调用零地址）。创建合约的调用 create calls 和普通消息调用的唯一区别在于，负载会被执行，执行的结果被存储为合约代码，调用者/创建者在栈上得到新合约的地址。

### 失效和自毁

#### 合约代码从区块链上移除的唯一方式是合约在合约地址上的执行自毁操作 selfdestruct 。合约账户上剩余的以太币会发送给指定的目标，然后其存储和代码从状态中被移除。移除一个合约听上去不错，但其实有潜在的危险，如果有人发送以太币到移除的合约，这些以太币将永远提丢失。

#### 尽管一个合约的代码中没有显式地调用 selfdestruct ，它仍然有可能通过 delegatecall 或 callcode 执行自毁操作。

## abi 用于编码结构化数据

### abi.encode

### abi.encodePacked

### abi.encodeWithSelector

### abi.encodeWithSignature

## 开发环境 truffle

### truffle

#### 1：创建并初始化项目
truffle init

#### truffle是本地的用来编译、部署智能合约的工具

#### 2：编译合约
truffle develop
truffle compile 仅默认编译自上次编译后被修改过的文件，来减少不必要的编译
truffle compile --compile-all 编译全部文件

#### 3:合约部署
修改部署js文件
truffle migrate
truffle migrate --reset 重新部署

#### 4:合约调用
如果合约方法没有 constant 或 pure修饰，调用时要使用.call（）调用。

#### 约定：
Truffle需要定义的合约名称和文件名准确匹配。

### TestRPC

#### testrpc是在本地使用内存模拟的一个以太坊环境，对于开发调试来说，更为方便快捷。
它在执行交易时是实时返回，而不等待默认的出块时间，这样你可以快速验证你新写的代码，当出现错误时，也能即时反馈给你。

#### 打开TestRPC
终端输入testrpc命令

#### testrpc会默认给你十个测试账号用来调试。
当在truffle操作时，在当前终端中会打印日志信息。

### ganache

#### Ganache是一个运行在个人桌面上的以太坊开发者的个人区块链

#### 通过使用Ganache，你可以快速的看到你的应用是如何影响区块链的。其中细节：如你的账户、余额、合约及Gas成本。

#### 快速查看所有账户的当前状态，包括他们的地址、私钥、交易和余额
查看Ganache内部区块链的日志输出，包括响应和其他重要的调试信息
检查所有块和交易，以获取相关问题的信息

## solidity内置API

### 时间及日期

#### 1= 1 seconds
1 minutes= 60 seconds
1 hours = 60 minutes
1 days = 24 hours
1 weeks = 7 days
1 years = 365 days

#### 获取当前时间
now   返回uint类型

#### 一个函数一天只能执行一次？？

##### 每次调用时和上次调用时间比较，并更新调用时间
 function doSomething() public {
	if(now >= lastTs +1 days){
	    //doSomething
	   }
	   lastTs = now;
} 

#### 第三方工具类
https://github.com/pipermerriam/ethereum-datetime

### 区块及交易信息API

#### ABI
应用程序二进制接口

#### hash函数

##### SHA1

##### SHA2 : SHA-224 、SHA-256  SHA-384 、SHA-256

##### SHA3：keccak

## 引用类型

### mermory(值传递)
任何函数参数当它的类型为引用类型时，这个函数参数都默认为memory类型，memory类型的变量会临时拷贝一份值存储到内存中，当我们将这个参数值赋给一个新的变量，并尝试去修改这个新的变量的值时，最原始的变量的值并不会发生变化。

### storage（指针传递）
storage类型的函数参数将是指针传递
注：
当我们的函数参数如果为storage类型时，函数的类型必须为internal或者private

## 注意点

### 竞拍合约返回出价

#### 返还出价时，简单地直接调用 highestBidder.send(highestBid) 函数，是有安全风险的，因为它有可能执行一个非信任合约。更为安全的做法是让接收方自己提取金钱。
 pendingReturns[highestBidder] += highestBid;
对外提供体现方法让用户自己去触发体现

#### 提现方法

##### 这里很重要，首先要设零值。因为，作为接收调用的一部分，接收者可以在 `send` 返回之前，重新调用该函数。
pendingReturns[msg.sender] = 0;if (!msg.sender.send(amount)) {
 // 这里不需抛出异常，只需重置未付款
pendingReturns[msg.sender] = amount;
return false;
 }

### 与外部合约交互

####  对于可与其他合约交互的函数（意味着它会调用其他函数或发送以太币）
 一个好的指导方针是将其结构分为三个阶段：
 1. 检查条件
 2. 执行动作 (可能会改变条件)
 3. 与其他合约交互

## 事件event

### 事件是以太坊虚拟机(EVM)日志基础设施提供的一个便利接口。
当被发送事件（调用）时，会触发参数存储到交易的日志中（一种区块链上的特殊数据结构）。这些日志与合约的地址关联，并记录到区块链中.
来捋这个关系：区块链是打包一系列交易的区块组成的链条，每一个交易“收据”会包含0到多个日志记录，日志代表着智能合约所触发的事件。
在DAPP的应用中，如果监听了某事件，当事件发生时，会进行回调。
不过要注意：日志和事件在合约内是无法被访问的，即使是创建日志的合约。

### 在Solidity 代码中，使用event 关键字来定义一个事件，
如：event EventName(address bidder, uint amount); 

### 这个用法和定义函数式一样的，并且事件在合约中同样可以被继承

### https://xiaozhuanlan.com/topic/1568432079

## Javascript VM：简单的Javascript虚拟机环境，纯粹练习智能合约编写的时候可以选择
Injected Web3：连接到嵌入到页面的Web3，比如连接到MetaMask
Web3 Provider：连接到自定义的节点，如私有的测试网络。

## transfer()和send()区别

### send()成员函数
发生错误时不抛出异常而是返回false，使用时要检查返回值

### transfer()
转账出错会抛出异常

### send()和transfer()有2300gas的限制，当合约接受或转账时很容易失败

## 单位

### ether、finney、szabo、wei

### 1ether = 1000finney
1ether = 1000000szabo
1ether = 10 ** 18 wei

## web3.js

### Web3.js API 基本

### web3是对jsonRPC的封装，可以直接使用geth的方法
现在有0.20和1.0版本，1.0对0.20版本进行了重构、模块化。
1.0引入了promise简化了异步编程，将异步操作以同步操作流程表达出来，避免层层嵌套的回调。

## Zeppelin

### 用于区块链应用的开源安全智能合约架构

### 简化加密钱包开发过程，
zeppelin是一套能够给我们方便提供编写加密合约的函数库，同时里面也提供了兼容ERC20的只能合约。

### Zeppelin是一个社区驱动项目，目的在于实现安全的、经测试的且经审计的智能合约代码开发。

### 创建zeppelin标准代币
1.创建项目目录并进入该目录
2.创建配置文件package.json : npm init
3.创建项目 truffle init
4.安装 zeppelin-solidity

### 安装 zeppelin 
npm install zeppelin-solidity

## 特殊变量和方法

### block

#### .blickhash（uint blockNumber） reuruns (bytes32) : 某个区块的hash值
.coinbase（address） :当前区块的挖矿地址
.difficulty（uint） ：当前区块的难度
.gaslimit（uint）： 当前区块的gaslimit
.number（uint）:当前区块编号
.timestamp（uint） :当前区块时间戳

### msg

#### .data（bytes） :参数
.gas（uint）：剩余gas
.sender（address）:当前发送消息的地址
.sig(byte4)：方法ID
.value（uint）:伴随消息福袋的以太币数量

### now :时间戳 ，等价于block.timestamp

### tx

#### .gasPrice 交易的gas单价

#### .origin 交易发送的地址

## 速查表

## EIP

### EIP-712

#### 对结构化数据哈希和签名的标准,旨在提高链下消息签名对链上的可用性

## ABI

### Application Binary Interface,应用程序二进制接口，简单来说就是 以太坊的调用合约时的接口说明

### 调用合约函数其实是向合约地址（账户）提交了一个交易，这个交易有一个附加数据，这个附加的数据就是ABI的编码数据。

#### 比特币的交易也可以附加数据，以太坊革命性的地方就是能把附加数据转化为都函数的执行。
